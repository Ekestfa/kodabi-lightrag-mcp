# REQ202511272348 - Provide Basic Access to LightRAG via HTTP Server

## Overview

This document outlines the implementation of HTTP access to the local LightRAG microservices, enabling users to interact with multiple RAG microservices through a unified, centralized server for `MVP001`. The system supports query routing, health checks, and dynamic execution of complex workflows involving multiple microservices with specified calling orders and roles.

The core functionality is built around a central RAG server that acts as a gateway, routing HTTP requests to appropriate microservices based on port numbers, query context, and predefined roles. This design allows users to query different RAG microservices—such as Software Engineering RAG on port 8080 or History RAG on port 8081—using a single server endpoint, while maintaining secure, reliable, and scalable operations.

---

## Key Functional Components

### 1. HTTP Access to RAG Microservices via Port Specification (REQ202511272348-US01)

The central RAG server accepts queries specifying a microservice name and associated port number (e.g., "Software Engineering RAG: 8080"). Upon receiving such a request:

- The server validates the microservice name and port number against its configuration.
- If valid, it routes the query to the corresponding microservice running on the specified port.
- The targeted microservice retrieves context from its vector database and returns a contextual response with source document information.
- The central server assembles and returns the final response to the user.

**Error Handling**:
- If the port is invalid or non-existent, the server returns a clear error message indicating the invalid port and lists all available microservices with their port numbers.
- If the microservice name is not found, the server returns a message stating the microservice is not available and lists all configured microservices.
- If the input is malformed or missing a required parameter (e.g., port), the server rejects the request and returns an error indicating the port is required.

This capability enables users to query any RAG microservice with only a single server interface, simplifying integration and reducing complexity.

---

### 2. Health Check via `/health` API (REQ202511272348-US02)

Before initiating any RAG operations, the system performs a health check using the `/health` endpoint. This ensures that the server is operational and ready to serve requests.

- A user-initiated workflow triggers an HTTP GET request to `/health`.
- If the server responds with a `200 OK`, the workflow proceeds with RAG operations.
- If the server returns a `503 Service Unavailable` or `404 Not Found`, the workflow is halted with a clear error message indicating the server is unavailable.
- If the response is malformed or non-JSON, the system logs a warning and triggers a fallback mechanism (e.g., attempting alternative endpoints or restarting the server).
- If there is a network timeout, the system responds with a `504 Gateway Timeout` error and halts the workflow until the issue is resolved.

This health check acts as a gatekeeper, ensuring that all RAG operations begin only when the server is confirmed to be healthy and responsive.

---

### 3. Query via Web Server (`/query` API) (REQ202511272348-US03)

The web server at `http://[::1]:8080` serves as a secure gateway to the RAG system. Users can send HTTP POST requests to the `/query` endpoint to retrieve context from the RAG system.

- The server validates the request body and forwards it to the RAG system’s `/query` API.
- The RAG system retrieves relevant context from its vector database and returns a structured response containing the answer and source document information.
- The web server returns this response to the user.

**Error Handling**:
- If the query parameter is missing or malformed, the server returns a `400 Bad Request` error with a clear message.
- If the RAG service fails (e.g., returns a 500 error), the server logs the failure and returns a `503 Service Unavailable` response with a message indicating the RAG service is inaccessible.
- If the API token is invalid or missing, the server returns a `401 Unauthorized` response and logs the authentication failure for security auditing.

This endpoint supports both direct queries and integration with external applications.

---

### 4. Query Multiple Microservices with Context (REQ202511272348-US04)

The system supports routing queries to multiple microservices based on context and domain. For example, a query about user preferences may require data from a user history microservice, a product catalog, and real-time pricing.

- The system evaluates whether the query contains sufficient context to determine which microservices should respond.
- If context is sufficient, it routes the query to relevant microservices.
- Each microservice retrieves its domain-specific data (e.g., user history, product catalog).
- The retrieved data is aggregated and validated for consistency.
- A unified, context-aware response is generated with clear source attribution and returned to the user.

**Error Handling**:
- If the query is ambiguous, the system returns a response indicating uncertainty and suggests clarifying the query or selecting specific microservices.
- If one microservice fails or is unavailable, the system logs the error, continues with remaining functional microservices, and returns a partial result with a clear annotation about the missing data source.
- If the query is malformed, the system detects the syntax error and returns a corrective error message without initiating any microservice calls.

This enables rich, multi-source reasoning and ensures robustness in the face of partial failures.

---

### 5. Query with Specified Calling Order (REQ202511272348-US05)

Users can define a sequence of microservices to be queried in a specific order (e.g., "first from movie database, then from product catalog").

- The system validates the input and parses the calling order.
- It checks the existence of each microservice in the sequence.
- For each valid microservice, it executes a query in sequence, retrieving context from each.
- Before each query, it checks for redundancy (e.g., duplicate calls to the same microservice) and skips redundant calls.
- The retrieved context is aggregated into a unified context pool.
- A final, context-aware response is generated and returned to the user.

**Error Handling**:
- If a microservice in the calling order does not exist or is unreachable, the system returns a clear error message indicating the non-existent service.
- If the user prompt or query is malformed or empty, a validation error is returned immediately, and no microservice calls are initiated.

This supports complex, sequential workflows and ensures efficient execution by avoiding redundant operations.

---

### 6. Query with Role-Based Routing (REQ202511272348-US06)

The system dynamically routes queries to microservices based on their defined roles (e.g., document retrieval, real-time data analysis, product recommendations).

- Upon receiving a query, the system analyzes the intent and determines which microservices should handle specific aspects.
- It routes the query to the appropriate microservice based on role.
- Each microservice retrieves relevant data from its domain.
- The responses are aggregated and presented to the user as a unified, context-aware output.

**Error Handling**:
- If the query is ambiguous, the system requests clarification and returns a response indicating the ambiguity.
- If a required microservice becomes unavailable, the system attempts a fallback service or provides a partial response based on available data.
- If the query is malformed, the system returns a clear error message with guidance on how to correct it.

This enables intelligent, role-based decision-making and supports diverse application domains.

---

## Technical Implementation Details

- **Central RAG Server**: Acts as a gateway, routing queries to microservices based on port and role. It validates inputs, manages authentication, and orchestrates execution.
- **Microservices**: Each RAG microservice runs independently on a designated port (e.g., 8080, 8081) and exposes a `/query` API endpoint.
- **Authentication**: The system requires an API token and base URL for secure access, passed via configuration.
- **Vector Database**: All microservices retrieve context from a vector database using semantic similarity search.
- **Communication**: The system uses HTTP-based APIs with asynchronous operations to ensure responsiveness and scalability.
- **Deployment**: All microservices are containerized and deployed on Kubernetes for scalability, fault tolerance, and dynamic scaling.

---

## Validation and Testing Strategy

- **Unit Testing**: Each user task is tested with valid and invalid inputs to verify error handling, response generation, and input validation.
- **User Acceptance Testing (UAT)**: Real users test sample queries to validate usability, response quality, and accuracy.
- **Error Logging**: All error conditions are logged with sufficient detail (e.g., error type, parameter, timestamp) for debugging and monitoring.
- **Security Auditing**: All authentication failures are logged for compliance with security policies.